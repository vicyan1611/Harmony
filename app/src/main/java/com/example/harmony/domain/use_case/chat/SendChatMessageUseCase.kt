package com.example.harmony.domain.use_case.chat

import android.net.Uri
import com.example.harmony.core.common.Resource
import com.example.harmony.domain.model.Message
import com.example.harmony.domain.model.ParticipantInfo
import com.example.harmony.domain.repository.AuthRepository
import com.example.harmony.domain.repository.DirectMessageRepository
import com.example.harmony.domain.repository.MessageRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import javax.inject.Inject

class SendChatMessageUseCase @Inject constructor(
    private val messageRepository: MessageRepository,
    private val dmRepository: DirectMessageRepository,
    private val authRepository: AuthRepository
) {
    operator fun invoke(

        serverId: String? = null,
        channelId: String? = null,
        conversationId: String? = null,

        text: String = "",
        imageUri: Uri? = null,

        otherUserInfo: ParticipantInfo? = null
    ): Flow<Resource<Unit>> {
        val currentUser = authRepository.getCurrentUser()
        if (currentUser == null) {
            return flow { emit(Resource.Error("User not logged in")) }
        }

        // Create the base message object
        val message = Message(
            // id is generated by Firestore
            channelId = channelId ?: "", // Set channelId if it's a channel message
            senderId = currentUser.id,
            senderDisplayName = currentUser.displayName,
            senderPhotoUrl = currentUser.photoUrl,
            text = if (imageUri == null) text else "", // Only include text if no image
            imageUrl = null
        )

        return when {
            // Sending to a Server Channel
            serverId != null && channelId != null -> {
                messageRepository.sendMessage(
                    serverId = serverId,
                    channelId = channelId,
                    message = message,
                    imageUri = imageUri
                )
            }
            // Sending a Direct Message
            conversationId != null && otherUserInfo != null -> {
                val currentUserInfo = ParticipantInfo(currentUser.displayName, currentUser.photoUrl)
                dmRepository.sendDirectMessage(
                    conversationId = conversationId,
                    message = message,
                    currentUserInfo = currentUserInfo,
                    otherUserInfo = otherUserInfo,
                    imageUri = imageUri
                )
            }
            // Invalid parameters
            else -> {
                flow { emit(Resource.Error("Invalid destination for message")) }
            }
        }
    }
}